// ============================================================================
// UBISOFT BOT - SEPARATE BOT FOR UBISOFT GAME TOKENS
// Uses same database as Steam bot, runs as separate process
// ============================================================================

require('dotenv').config();
const {
    Client, GatewayIntentBits, Partials, EmbedBuilder, ActionRowBuilder,
    ButtonBuilder, ButtonStyle, StringSelectMenuBuilder, ChannelType,
    SlashCommandBuilder, REST, Routes, PermissionFlagsBits
} = require('discord.js');
const path = require('path');
const fs = require('fs');
const { spawn, exec } = require('child_process');
const fetch = require('node-fetch');

// DATABASE - Same as Steam bot
const db = require('./database/db');
db.initDatabase();

// CONFIGURATION
const config = {
    token: process.env.UBISOFT_BOT_TOKEN,
    guildId: process.env.UBISOFT_GUILD_ID || (process.env.GUILD_ID || '').split(',')[0].trim(),
    ticketChannelId: process.env.UBISOFT_TICKET_CHANNEL_ID || process.env.FORUM_CHANNEL_ID,
    staffRoleIds: (process.env.STAFF_ROLE_IDS || '').split(',').filter(Boolean),
    denuvoExePath: process.env.DENUVO_EXE_PATH || path.join(__dirname, 'ubisoft', 'DenuvoTicket.exe'),
    tokenOutputPath: process.env.DENUVO_TOKEN_PATH || path.join(__dirname, 'ubisoft', 'token'),
};

// DISCORD CLIENT
const client = new Client({
    intents: [
        GatewayIntentBits.Guilds,
        GatewayIntentBits.GuildMessages,
        GatewayIntentBits.MessageContent,
        GatewayIntentBits.GuildMembers
    ],
    partials: [Partials.Channel, Partials.Message]
});

const activeUbisoftTickets = new Map();

function generateTicketId() {
    const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
    let id = 'UBI-';
    for (let i = 0; i < 6; i++) id += chars.charAt(Math.floor(Math.random() * chars.length));
    return id;
}

function ensureDirectories() {
    const dirs = [path.dirname(config.denuvoExePath), config.tokenOutputPath];
    dirs.forEach(dir => {
        if (!fs.existsSync(dir)) {
            fs.mkdirSync(dir, { recursive: true });
            console.log('[Ubisoft] Created directory:', dir);
        }
    });
}

// PANEL CREATION
async function createUbisoftPanel(channel, panelType = 'free') {
    try {
        const games = db.getUbisoftGamesByPanel(panelType);
        if (games.length === 0) return channel.send(`No ${panelType} Ubisoft games available.`);

        const options = games.map(game => ({
            label: game.game_name.substring(0, 100),
            description: `${db.getAvailableUbisoftTokenCount(game.id)}/${db.getTotalUbisoftTokenCount(game.id)} tokens`,
            value: `ubisoft_game_${game.id}`,
            emoji: db.getAvailableUbisoftTokenCount(game.id) > 0 ? 'üü¢' : 'üî¥'
        }));

        const menu = new StringSelectMenuBuilder()
            .setCustomId(`ubisoft_panel_${panelType}_0`)
            .setPlaceholder('üéØ Select a Ubisoft game...')
            .addOptions(options.slice(0, 25));

        const embed = new EmbedBuilder()
            .setTitle(`üéØ Ubisoft ${panelType === 'free' ? 'Free' : 'Paid'} Games`)
            .setDescription(`**Select a game to request a token**\n\nüü¢ = Available | üî¥ = Out of stock\n\n**${games.length}** games available`)
            .setColor(panelType === 'free' ? 0x00ff00 : 0xffd700)
            .setFooter({ text: 'Ubisoft Token System' })
            .setTimestamp();

        await channel.send({ embeds: [embed], components: [new ActionRowBuilder().addComponents(menu)] });
        console.log(`[Ubisoft] Created ${panelType} panel with ${games.length} games`);
    } catch (error) {
        console.error('[Ubisoft] Error creating panel:', error);
    }
}

// TICKET CREATION
async function createUbisoftTicket(interaction, gameId) {
    try {
        const game = db.getUbisoftGame(gameId);
        if (!game) return interaction.reply({ content: '‚ùå Game not found.', ephemeral: true });

        if (db.getAvailableUbisoftTokenCount(gameId) === 0) {
            return interaction.reply({ content: `‚ùå **${game.game_name}** is out of tokens. Try again later.`, ephemeral: true });
        }

        const ticketChannel = await client.channels.fetch(config.ticketChannelId);
        if (!ticketChannel || ticketChannel.type !== ChannelType.GuildForum) {
            return interaction.reply({ content: '‚ùå Ticket channel not configured. Contact staff.', ephemeral: true });
        }

        const ticketId = generateTicketId();
        const user = interaction.user;

        const thread = await ticketChannel.threads.create({
            name: `üéØ ${ticketId} - ${user.username}`,
            message: { content: `üéØ **Ubisoft Token Request**\nUser: ${user}\nGame: ${game.game_name}\nTicket: ${ticketId}` }
        });

        let downloadLinks = {};
        try { if (game.download_links) downloadLinks = JSON.parse(game.download_links); } catch (e) {}

        let linksText = '';
        Object.entries(downloadLinks).forEach(([key, url]) => {
            if (url) linksText += `üì• **[${key}](${url})**\n`;
        });

        const embed = new EmbedBuilder()
            .setTitle(`üéØ ${game.game_name}`)
            .setDescription(
                `Welcome ${user}!\n\n` +
                `**üì• Required Downloads:**\n${linksText || '*No download links configured*'}\n\n` +
                `**üìã Instructions:**\n${game.instructions || '1. Download and extract files\n2. Run the dumper\n3. Upload the generated .txt file here'}\n\n` +
                `**When ready, upload your .txt file below.**`
            )
            .setColor(0x7289da)
            .setThumbnail(game.cover_url || null)
            .setFooter({ text: `Ticket: ${ticketId}` })
            .setTimestamp();

        await thread.send({
            embeds: [embed],
            components: [new ActionRowBuilder().addComponents(
                new ButtonBuilder().setCustomId(`ubisoft_cancel_${ticketId}`).setLabel('Cancel Request').setStyle(ButtonStyle.Danger).setEmoji('‚ùå')
            )]
        });

        activeUbisoftTickets.set(thread.id, {
            ticketId,
            odid: user.id,
            userName: user.username,
            gameId: game.id,
            gameName: game.game_name,
            threadId: thread.id,
            status: 'waiting_txt',
            createdAt: Date.now()
        });

        await interaction.reply({ content: `‚úÖ Ticket created! Go to ${thread} to continue.`, ephemeral: true });
        console.log(`[Ubisoft] Created ticket ${ticketId} for ${user.username} - ${game.game_name}`);
    } catch (error) {
        console.error('[Ubisoft] Error creating ticket:', error);
        await interaction.reply({ content: '‚ùå Error creating ticket.', ephemeral: true }).catch(() => {});
    }
}

// TXT FILE PROCESSING
async function processUbisoftTxtFile(message, ticket) {
    try {
        const attachment = message.attachments.find(a => a.name.endsWith('.txt'));
        if (!attachment) return;

        const response = await fetch(attachment.url);
        const txtContent = await response.text();

        if (!txtContent || txtContent.trim().length < 10) {
            await message.reply('‚ùå The uploaded file appears to be empty or invalid.');
            return;
        }

        ticket.status = 'processing';
        ticket.txtContent = txtContent.trim();

        const processingMsg = await message.channel.send({
            embeds: [new EmbedBuilder().setTitle('‚è≥ Processing Token Request').setDescription('Your file has been received. Generating token...\nThis may take a minute.').setColor(0xffa500).setTimestamp()]
        });

        const tokenData = db.getAvailableUbisoftToken(ticket.gameId);
        if (!tokenData) {
            await processingMsg.edit({
                embeds: [new EmbedBuilder().setTitle('‚ùå No Tokens Available').setDescription('All tokens are on cooldown. Try again later.').setColor(0xff0000)]
            });
            ticket.status = 'no_tokens';
            return;
        }

        const result = await runDenuvoExe(tokenData, txtContent, ticket);

        if (result.success) {
            db.markUbisoftTokenUsed(tokenData.id, ticket.odid, ticket.userName, ticket.ticketId);
            db.logUbisoftActivation(tokenData.id, tokenData.account_id, ticket.gameId, ticket.odid, ticket.userName, ticket.ticketId, true, null);

            const successEmbed = new EmbedBuilder()
                .setTitle('‚úÖ Token Generated Successfully!')
                .setDescription(`Your token has been generated.\n\n**Output:**\n\`\`\`\n${result.output.substring(0, 1500)}\n\`\`\``)
                .setColor(0x00ff00)
                .setTimestamp();

            await processingMsg.edit({
                embeds: [successEmbed],
                components: [new ActionRowBuilder().addComponents(
                    new ButtonBuilder().setCustomId(`ubisoft_works_${ticket.ticketId}`).setLabel('It Works!').setStyle(ButtonStyle.Success).setEmoji('‚úÖ'),
                    new ButtonBuilder().setCustomId(`ubisoft_help_${ticket.ticketId}`).setLabel('Need Help').setStyle(ButtonStyle.Danger).setEmoji('‚ùì')
                )]
            });

            if (result.outputFile && fs.existsSync(result.outputFile)) {
                await message.channel.send({ content: 'üìÅ **Token File:**', files: [result.outputFile] });
            }

            ticket.status = 'completed';
        } else {
            if (result.error && (result.error.includes('Daily limit') || result.error.includes('ExceededActivations'))) {
                db.markAllUbisoftTokensExhausted(tokenData.account_id, ticket.gameId);
                console.log(`[Ubisoft] Account ${tokenData.account_name} exhausted for game ${ticket.gameName}`);

                const altToken = db.getAvailableUbisoftToken(ticket.gameId);
                if (altToken && altToken.account_id !== tokenData.account_id) {
                    await processingMsg.edit({
                        embeds: [new EmbedBuilder().setTitle('‚è≥ Trying Alternative Account...').setDescription('First account hit daily limit, trying another...').setColor(0xffa500)]
                    });

                    const retryResult = await runDenuvoExe(altToken, txtContent, ticket);
                    if (retryResult.success) {
                        db.markUbisoftTokenUsed(altToken.id, ticket.odid, ticket.userName, ticket.ticketId);
                        db.logUbisoftActivation(altToken.id, altToken.account_id, ticket.gameId, ticket.odid, ticket.userName, ticket.ticketId, true, null);

                        await processingMsg.edit({
                            embeds: [new EmbedBuilder().setTitle('‚úÖ Token Generated Successfully!').setDescription(`**Output:**\n\`\`\`\n${retryResult.output.substring(0, 1500)}\n\`\`\``).setColor(0x00ff00)],
                            components: [new ActionRowBuilder().addComponents(
                                new ButtonBuilder().setCustomId(`ubisoft_works_${ticket.ticketId}`).setLabel('It Works!').setStyle(ButtonStyle.Success),
                                new ButtonBuilder().setCustomId(`ubisoft_help_${ticket.ticketId}`).setLabel('Need Help').setStyle(ButtonStyle.Danger)
                            )]
                        });

                        if (retryResult.outputFile && fs.existsSync(retryResult.outputFile)) {
                            await message.channel.send({ content: 'üìÅ **Token File:**', files: [retryResult.outputFile] });
                        }

                        ticket.status = 'completed';
                        return;
                    } else {
                        db.markAllUbisoftTokensExhausted(altToken.account_id, ticket.gameId);
                    }
                }
            }

            db.logUbisoftActivation(tokenData.id, tokenData.account_id, ticket.gameId, ticket.odid, ticket.userName, ticket.ticketId, false, result.error);

            const staffPing = config.staffRoleIds.map(id => `<@&${id}>`).join(' ');
            await processingMsg.edit({
                content: staffPing,
                embeds: [new EmbedBuilder().setTitle('‚ùå Token Generation Failed').setDescription(`An error occurred.\n\n**Error:** ${result.error || 'Unknown error'}\n\nStaff has been notified.`).setColor(0xff0000).setTimestamp()]
            });
            ticket.status = 'error';
        }
    } catch (error) {
        console.error('[Ubisoft] Error processing txt file:', error);
        await message.reply('‚ùå An error occurred. Please try again or wait for staff.');
    }
}

// DENUVO EXE RUNNER - Uses interactive mode with SendKeys automation
async function runDenuvoExe(tokenData, txtContent, ticket) {
    return runDenuvoExeInteractive(tokenData, txtContent, ticket);
}

// Automate interactive mode using PowerShell SendKeys
async function runDenuvoExeInteractive(tokenData, txtContent, ticket) {
    return new Promise((resolve) => {
        try {
            if (!fs.existsSync(config.denuvoExePath)) {
                resolve({ success: false, error: 'Token generator not configured. Contact staff.' });
                return;
            }

            if (!fs.existsSync(config.tokenOutputPath)) {
                fs.mkdirSync(config.tokenOutputPath, { recursive: true });
            }

            // Clean up any old output files first
            const outputFile = path.join(config.tokenOutputPath, 'token.txt');
            try { fs.unlinkSync(outputFile); } catch (e) {}

            const email = tokenData.email.replace(/'/g, "''");
            const password = tokenData.password.replace(/'/g, "''");
            const exeDir = path.dirname(config.denuvoExePath);
            const exeName = path.basename(config.denuvoExePath);
            
            // Create PowerShell script for SendKeys automation
            const psScript = path.join(config.tokenOutputPath, `run_${ticket.ticketId}.ps1`);
            const tokenClean = txtContent.trim().replace(/'/g, "''");
            
            const psContent = `
Add-Type -AssemblyName System.Windows.Forms

# Start the exe
$process = Start-Process -FilePath '${config.denuvoExePath.replace(/'/g, "''")}' -ArgumentList '-u','${email}','-p','${password}' -WorkingDirectory '${exeDir.replace(/'/g, "''")}' -PassThru

# Wait for window to be ready
Start-Sleep -Seconds 2

# Send "1" to select account
[System.Windows.Forms.SendKeys]::SendWait("1")
[System.Windows.Forms.SendKeys]::SendWait("{ENTER}")
Start-Sleep -Seconds 2

# Send "2" for legacy format
[System.Windows.Forms.SendKeys]::SendWait("2")
[System.Windows.Forms.SendKeys]::SendWait("{ENTER}")
Start-Sleep -Seconds 1

# Copy token to clipboard and paste
$token = '${tokenClean}'
Set-Clipboard -Value $token
[System.Windows.Forms.SendKeys]::SendWait("^v")
Start-Sleep -Milliseconds 500
[System.Windows.Forms.SendKeys]::SendWait("{ENTER}")

# Wait for process to complete (max 60 seconds)
$process | Wait-Process -Timeout 60 -ErrorAction SilentlyContinue

# Check if still running and kill if needed
if (!$process.HasExited) {
    $process | Stop-Process -Force
}

Write-Output "Done"
`;
            fs.writeFileSync(psScript, psContent);
            console.log(`[Ubisoft] Running interactive automation for ${ticket.ticketId}`);

            exec(`powershell -ExecutionPolicy Bypass -File "${psScript}"`, {
                cwd: exeDir,
                timeout: 90000,
                maxBuffer: 1024 * 1024
            }, (error, stdout, stderr) => {
                // Clean up script
                try { fs.unlinkSync(psScript); } catch (e) {}

                console.log('[Ubisoft] Automation completed');
                if (stdout) console.log('[Ubisoft] stdout:', stdout.trim());
                if (stderr) console.log('[Ubisoft] stderr:', stderr.trim());

                // Check for output file
                const legacyFile = path.join(config.tokenOutputPath, 'token.txt');
                const dbdataFile = path.join(config.tokenOutputPath, 'dbdata.json');

                let resultFile = null;
                let resultContent = '';

                // Wait a moment for file to be written
                setTimeout(() => {
                    if (fs.existsSync(legacyFile)) {
                        resultFile = legacyFile;
                        resultContent = fs.readFileSync(legacyFile, 'utf8');
                        console.log(`[Ubisoft] Found output: ${legacyFile}`);
                    }
                    if (fs.existsSync(dbdataFile)) {
                        resultFile = dbdataFile;
                        resultContent = fs.readFileSync(dbdataFile, 'utf8');
                        console.log(`[Ubisoft] Found output: ${dbdataFile}`);
                    }

                    if (resultFile && resultContent.length > 10) {
                        resolve({ success: true, output: resultContent.substring(0, 2000), outputFile: resultFile });
                    } else {
                        resolve({ success: false, error: stderr || stdout || 'No token file generated. Try again or contact staff.' });
                    }
                }, 2000);
            });

        } catch (error) {
            console.error('[Ubisoft] Error:', error);
            resolve({ success: false, error: error.message });
        }
    });
}

// BUTTON HANDLERS
async function handleUbisoftButton(interaction) {
    const customId = interaction.customId;

    if (customId.startsWith('ubisoft_works_')) {
        await interaction.reply({ content: '‚úÖ Great! Glad it worked. This ticket will be closed shortly.' });
        setTimeout(async () => {
            try {
                if (interaction.channel && interaction.channel.isThread()) {
                    await interaction.channel.setArchived(true);
                }
                activeUbisoftTickets.delete(interaction.channel.id);
            } catch (e) {}
        }, 5000);
    } else if (customId.startsWith('ubisoft_help_')) {
        const staffPing = config.staffRoleIds.map(id => `<@&${id}>`).join(' ');
        await interaction.reply({ content: `üÜò Staff has been notified!\n${staffPing}` });
    } else if (customId.startsWith('ubisoft_cancel_')) {
        await interaction.reply({ content: '‚ùå Request cancelled. Closing ticket...' });
        setTimeout(async () => {
            try {
                if (interaction.channel && interaction.channel.isThread()) {
                    await interaction.channel.setArchived(true);
                }
                activeUbisoftTickets.delete(interaction.channel.id);
            } catch (e) {}
        }, 3000);
    }
}

// SLASH COMMANDS
const commands = [
    new SlashCommandBuilder()
        .setName('ubisoft-panel')
        .setDescription('Create a Ubisoft game selection panel')
        .addStringOption(option =>
            option.setName('type')
                .setDescription('Panel type')
                .setRequired(true)
                .addChoices(
                    { name: 'Free', value: 'free' },
                    { name: 'Paid', value: 'paid' }
                ))
        .setDefaultMemberPermissions(PermissionFlagsBits.ManageChannels),

    new SlashCommandBuilder()
        .setName('ubisoft-status')
        .setDescription('Check Ubisoft token availability')
        .setDefaultMemberPermissions(PermissionFlagsBits.ManageChannels),
];

async function registerCommands() {
    try {
        if (!config.guildId) {
            console.error('[Ubisoft] No GUILD_ID configured, cannot register commands');
            return;
        }
        const rest = new REST({ version: '10' }).setToken(config.token);
        await rest.put(
            Routes.applicationGuildCommands(client.user.id, config.guildId),
            { body: commands }
        );
        console.log('[Ubisoft] ‚úÖ Slash commands registered for guild:', config.guildId);
    } catch (error) {
        console.error('[Ubisoft] Error registering commands:', error.message);
    }
}

// EVENT HANDLERS
client.once('ready', async () => {
    console.log(`[Ubisoft] ‚úÖ Bot logged in as ${client.user.tag}`);
    console.log(`[Ubisoft] Guild ID: ${config.guildId}`);
    console.log(`[Ubisoft] Ticket Channel: ${config.ticketChannelId}`);
    await registerCommands();
    ensureDirectories();
    client.user.setActivity('Ubisoft Games', { type: 3 });
    console.log('[Ubisoft] ‚úÖ Ready to process Ubisoft token requests');
});

client.on('interactionCreate', async (interaction) => {
    try {
        if (interaction.isChatInputCommand()) {
            if (interaction.commandName === 'ubisoft-panel') {
                const panelType = interaction.options.getString('type');
                await interaction.deferReply({ ephemeral: true });
                await createUbisoftPanel(interaction.channel, panelType);
                await interaction.editReply({ content: '‚úÖ Panel created!' });
            } else if (interaction.commandName === 'ubisoft-status') {
                const games = db.getAllUbisoftGames();
                let statusText = '**Ubisoft Token Status:**\n\n';
                games.forEach(game => {
                    const available = db.getAvailableUbisoftTokenCount(game.id);
                    const total = db.getTotalUbisoftTokenCount(game.id);
                    statusText += `${available > 0 ? 'üü¢' : 'üî¥'} **${game.game_name}**: ${available}/${total}\n`;
                });
                await interaction.reply({ content: statusText, ephemeral: true });
            }
        } else if (interaction.isStringSelectMenu()) {
            if (interaction.customId.startsWith('ubisoft_panel_')) {
                const gameId = interaction.values[0].replace('ubisoft_game_', '');
                await createUbisoftTicket(interaction, parseInt(gameId));
            }
        } else if (interaction.isButton()) {
            if (interaction.customId.startsWith('ubisoft_')) {
                await handleUbisoftButton(interaction);
            }
        }
    } catch (error) {
        console.error('[Ubisoft] Interaction error:', error);
        try {
            if (interaction.deferred || interaction.replied) {
                await interaction.editReply({ content: '‚ùå An error occurred.' });
            } else {
                await interaction.reply({ content: '‚ùå An error occurred.', ephemeral: true });
            }
        } catch (e) {}
    }
});

client.on('messageCreate', async (message) => {
    try {
        if (message.author.bot) return;
        if (!message.channel.isThread()) return;

        const ticket = activeUbisoftTickets.get(message.channel.id);
        if (!ticket) return;

        if (message.attachments.size > 0) {
            const txtAttachment = message.attachments.find(a => a.name.endsWith('.txt'));
            if (txtAttachment && ticket.status === 'waiting_txt') {
                await processUbisoftTxtFile(message, ticket);
            }
        }
    } catch (error) {
        console.error('[Ubisoft] Message handler error:', error);
    }
});

// STARTUP
if (!config.token) {
    console.error('[Ubisoft] ‚ùå ERROR: UBISOFT_BOT_TOKEN not set in .env');
    process.exit(1);
}

client.login(config.token).catch(err => {
    console.error('[Ubisoft] ‚ùå Login failed:', err.message);
    process.exit(1);
});

console.log('[Ubisoft] üéØ Starting Ubisoft Bot...');
